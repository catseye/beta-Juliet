<h2>Modifiers</h2>

<p>Unlike events, alphabets are ordered.  Each symbol
(except the first) in an alphabet has one and only
one <dfn>predecessor</dfn>, and each symbol (except the last) has one
and only one <dfn>successor</dfn>.</p>

<p>So the range of symbols in an alphabet is bounded.  However,
when considering a string of symbols (or a <dfn>symbol-string</dfn>), such as the name
of an event, we can use something resembling <dfn>Peano arithmetic</dfn>
to generate an unbounded sequence of symbol-strings, so long as each
symbol in a string is in the same alphabet.</p>

<p>Thus, for some alphabet, every symbol-string has one and only one successor.
Again, though, there is one symbol-string which has no predecessor — the symbol-string
which is one symbol long, where that symbol is the first symbol of the alphabet.</p>

<p>These concepts are implemented in 2Iota with <dfn>modifiers</dfn>.
When a parameter is named in a consequence, it is replaced by the value it is
bound to, and this can be altered by one of the following modifiers:</p>

<ul>
<li><code>next</code> — assuming the value is a single symbol, use the next symbol
in its alphabet instead;</li>
<li><code>prev</code> — assuming the value is a single symbol, use the previous symbol
in its alphabet instead;</li>
<li><code>succ</code> — assuming the value is a symbol-string, use the successor
symbol-string over its alphabet;</li>
<li><code>pred</code> — assuming the value is a symbol-string, use the predecessor
symbol-string over its alphabet instead.</li>
</ul>

<p>Note that all of these modifiers (except <code>succ</code>) can fail.  In this case,
an alternate or <code>failure-mode</code> modifier or symbol can be given, and this
will be used instead.</p>
