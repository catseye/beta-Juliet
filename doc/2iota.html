<html><head>
    <meta http-equiv="Content-Type" content="text/html; CHARSET=iso-8859-1">
    <meta name="Description" content="Cat's Eye Technologies: The 2Iota Programming Language">
    <title>Cat's Eye Technologies: The 2Iota Programming Language</title>
</head>
<body>
<h1>2Iota</h1>

<p><font size=-1>&nbsp;<img src="/images/icons/copyright.gif"
   align=absmiddle width=12 height=12 alt="(c)" border=0>2004 <a href="/">Cat's Eye Technologies</a>.  All rights reserved.<br>
    This software is OSI Certified Open Source Software.<br>
    OSI Certified is a certification mark of the <a href="http://www.opensource.org/"><img
    src="/images/icons/webicon.gif" alt="[WWW]" border=0 width=12 height=12>Open Source Initiative</a>.<br>
    See the file <a href="license.txt">license.txt</a> for license information.</font></p>

<h2>Overview</h2>

<p>2Iota is the successor language to the
<a href="/projects/b_juliet/">beta-Juliet and Portia languages</a>.
It is extremely similar  - nearly identical - in syntax and semantics to these languages,
with the following exceptions:

<ul>
<li>2Iota is a single language rather than a pair of mutual languages;</li>
<li>2Iota is Turing-Complete (or at least, closer to TC than beta-Juliet plus Portia);</li>
<li>2Iota does not (yet) implement <code>caused after|before|by</code> clauses;</li>
<li>2Iota explicitly reserves syntax for implementation-specific pragmas and system events;</li>
<li>2Iota's reference implementation is written in C rather than Perl;</li>
<li>2Iota's reference implementation implements delays correctly.</li>
</ul>
</p>

<h2>Events</h2>

<p>2Iota is a fairly "pure" event-oriented language.  In 2Iota, the world is
modelled as a set of <dfn>events</dfn> which have no inherent organization or ordering.
One such set might be <code>Domino Falls</code>, <code>Cat Meows</code>,
<code>Sun Sets</code>, <code>Address Line Six Goes High</code>
and <code>Greengrocer Falls Asleep on Subway</code>.</p>

<p>The occurance of each event may cause any number of other events to
happen - these are termed <dfn>consequences</dfn> of the event.  These
consequences may be conditional.  However, the only condition available for
checking is: <em>given two events, which one happened more recently?</em></p>

<h2>Patterns</h2>

<p>The names of events in 2Iota may be literal strings of <dfn>symbols</dfn>, exemplified
above, or they may be <dfn>patterns</dfn>.  Patterns contain <i>parameters</i>
and act something like regular expressions.  Each parameter ranges over a
specified <dfn>alphabet</dfn>.  When an event occurs which matches the name
of an event, the parameters in that name are bound to the literal symbols in the
occurring event.  These bound parameters may then be used in substitutions in
the consequences.</p>

<p>For example, if we have an alphabet called <code>Animal</code> that
consists of the symbols <code>Dog Cat Ferret</code>, we can
have an event <code>(X=Animal) Licks Itself</code> which has, as a
consequence, <code>(X) Becomes Clean</code>.  Here <code>X</code>
is a parameter.  This event will happen
should some other event cause <code>Cat Licks Itself</code>; <code>X</code>
will be bound to <code>Cat</code>, and this event will thus
subsequently cause the event <code>Cat Becomes Clean</code>.</p>

<h2>Modifiers</h2>

<p>Unlike events, alphabets are ordered.  Each symbol
(except the first) in an alphabet has one and only
one <dfn>predecessor</dfn>, and each symbol (except the last) has one
and only one <dfn>successor</dfn>.</p>

<p>So the range of symbols in an alphabet is bounded.  However,
when considering a string of symbols (or a <dfn>symbol-string</dfn>), such as the name
of an event, we can use something resembling <dfn>Peano arithmetic</dfn>
to generate an unbounded sequence of symbol-strings, so long as each
symbol in a string is in the same alphabet.</p>

<p>Thus, for some alphabet, every symbol-string has one and only one successor.
Again, though, there is one symbol-string which has no predecessor - the symbol-string
which is one symbol long, where that symbol is the first symbol of the alphabet.</p>

<p>These concepts are implemented in 2Iota with <dfn>modifiers</dfn>.
When a parameter is named in a consequence, it is replaced by the value it is
bound to, and this can be altered by one of the following modifiers:

<ul>
<li><code>next</code> - assuming the value is a single symbol, use the next symbol
in its alphabet instead;</li>
<li><code>prev</code> - assuming the value is a single symbol, use the previous symbol
in its alphabet instead;</li>
<li><code>succ</code> - assuming the value is a symbol-string, use the successor
symbol-string over its alphabet;</li>
<li><code>pred</code> - assuming the value is a symbol-string, use the predecessor
symbol-string over its alphabet instead.</li>
</ul>
</p>

<p>Note that all of these modifiers (except <code>succ</code>) can fail.  In this case,
an alternate or <code>failure-mode</code> modifier or symbol can be given, and this
will be used instead.</p>

</body></html>
